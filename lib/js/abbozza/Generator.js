/**
 * @license
 * abbozza!
 *
 * Copyright 2015 Michael Brinkmeier ( michael.brinkmeier@uni-osnabrueck.de )
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
/**
 * @fileoverview The Code Generator of Abbozza.
 * 
 * It provides several methods for the generation of code from
 * the blocks.
 * 
 * It allows to add erros, which are diaplayed by icons.
 * 
 * @author michael.brinkmeier@uni-osnabrueck.de (Michael Brinkmeier)
 */

 /**
  * Each value block has to have at most one of the following types:
  * "NUMBER", "TEXT", "DECIMAL, "BOOLEAN"
  * 
  * Each block can have the following types in addition:
  * "VAR"
  * 
  * Plug types
  * "ARR_DIM", "VAR_DECL"
  */

AbbozzaGenerator = function() {
	// this.ERROR = false;
	// this.ERROR_TEXT = "";
	// this.ERROR_BLOCK = null;
        this.serialRequired = false;
        this.preSetup = "";
	this.libraries = [];
        this.setupHookCode = "";
        this.startMonitor = false;
};


AbbozzaGenerator.prototype.setError = function (block, text) {
	console.log("AbbozzaGenerator.setError deprecated");
	// this.ERROR = true;
	// this.ERROR_TEXT = text;
	// this.ERROR_BLOCK = block;
}

AbbozzaGenerator.prototype.typeList = function() {
	return [[_("VOID"),"VOID"],[_("NUMBER"),"NUMBER"],[_("STRING"),"STRING"],[_("DECIMAL"),"DECIMAL"],[_("BOOLEAN"),"BOOLEAN"]];
}

__dict = [
		["VOID","void"],
		["NUMBER","int"],
		["STRING","String"],
		["DECIMAL","double"],
		["BOOLEAN","boolean"],
		["TRUE","true"],
		["FALSE","false"],
		["AND","&&"],
		["OR","||"],
		["EQUALS","=="],
		["INEQUAL","!="],
		["LESS","<"],
		["LESSEQ","<="],
		["GREATER",">"],
		["GREATEREQ",">="],		
		["ABS", "abs"],
		["SQRT", "sqrt"],
		["SIN", "sin"], 
		["COS", "cos"],
		["TAN", "tan"],
		["MIN", "min"],
		["MAX", "max"],
		["PLUS", "+"],
		["MINUS", "-"],
		["MULT", "*"],
		["DIV", "/"],
		["MOD", "%"],
		["POWER", "^"]
	];


keyword = function(tag) {
	for (var i = 0; i < __dict.length; i++) {
		if ( __dict[i][0] == tag ) 
		return __dict[i][1];
	}
	return tag;
}


AbbozzaGenerator.prototype.workspaceToCode = function(opt_workspace) {
  ErrorMgr.clearErrors();	
  this.startGenerator = false;
    
  this.serialRequired = false;
  this.startMonitor = false;
    
  var workspace = opt_workspace || Blockly.mainWorkspace;
  this.preSetup = "";
  this.setupHookCode = "";
  this.libraries = [];
  var code = "";
  // this.init(workspace);
  var origBlocks = workspace.getTopBlocks(true);
  var blocks = [null,null];   

  var temp = 2;
 
  for ( var i = 0; i<origBlocks.length; i++) {
    block = origBlocks[i];
    if ( block.type == "devices" ) {
    	blocks[0] = block;
    } else if ( block.type == "main" ) {
        blocks[1] = block;
    } else if ( block.type == "func_decl") {
        blocks.push(block);
    }
  }
  
  for (var x = 0; x < blocks.length; x++) {
    var block = blocks[x];
    if ( block ) {  // catching missing device block
        var line = this.topBlockToCode(block, "");
        if (line) {
            code = code + line;
        }
    }
  }

  if ( this.serialRequired == true ) {
    this.setupHookCode = this.setupHookCode + "Serial.begin(" + Abbozza.serialRate + ");" + "\n";
  }

  this.setupHookCode = "// setup hook\n" + this.setupHookCode;
  this.setupHookCode = this.setupHookCode.replace(/^/g,"\t");
  
  code = code.replace(/###setuphook###/g,"\t"+this.setupHookCode);
 
  code = this.finish(code);
  // Final scrubbing of whitespace.
  code = code.replace(/^\s+\n/, '');
  code = code.replace(/\n\s+$/, '\n');
  code = code.replace(/[ \t]+\n/g, '\n');

  return code;
};


/**
 * Prepend the generated code with the variable definitions.
 * @param {string} code Generated code.
 * @return {string} Completed code.
 */
AbbozzaGenerator.prototype.finish = function(code) {
       acode = "/**\n" +
	       " *  Generated by Abbozza!\n" +
	       " */\n\n";
       if (this.libraries.length != 0 ) {
           acode = acode + "/*\n * Bibliotheken\n */\n";
           for (var i = 0; i < this.libraries.length; i++) {
               acode = acode + "#include <" + this.libraries[i] + ">\n";
           }
           acode = acode + "\n";
       }
       if (this.preSetup != "" ) {
           acode = acode + "/*\n * Vorbereitungen\n */\n" + this.preSetup + "\n\n";
       }    
	return acode + code;
};


/**
 * This operation generates the code of a top block.
 */
AbbozzaGenerator.prototype.topBlockToCode = function(block) {
    
	var code = this._toCode(block);
        
        // Add a block comment before the generated code
	var comment = block.getCommentText();
	if ( comment.indexOf('\n') != -1 ) {
		comment = "/**\n * " + comment.replace(/\n/g,"\n * ");
		comment = comment + "\n */\n";
		code = comment + code + "\n";
	} else {
		// One comment line
 		if ( (comment != null) && (comment != "") ) {
 			comment = "// " + comment + "\n";
 		} else comment = "";
	 	code = comment +  code + "\n";
	}
 	return code;
}

/**
 * This operation generates the code of a sequence of statements connected to
 * 'block' at the input 'name'. 'prefix' is added to the beginning of each line. 
 */
AbbozzaGenerator.prototype.statementToCode = function(block, name, prefix) {
	var code = "";
        
        // Iterate through all statements
	var current = block.getInputTargetBlock(name);
	while (current) {
		var line = this.blockToCode(current);
		if ( line )
			code = code + line + "\n";
		current = current.getNextBlock();
	}
        // Add the prefix in front of the first line
        // and replace each newline by newline + prefix
	code = prefix + code;
	code = code.replace(/\n$/g,"");
	code = code.replace(/\n/g,"\n"+prefix);
        
	return code;
}

/**
 * This operation generates the code for the given block.
 */
AbbozzaGenerator.prototype.blockToCode = function(block) {
    
        // Call the blocks code generation operation
	var code = this._toCode(block);
        
        // Add an inline comment
	var comment = block.getCommentText();
	if ( (comment != null) && (comment != "" )) {
		code = code + "\t//" + comment;
	}
	
	return code;
}


AbbozzaGenerator.prototype._toCode = function(block) {
    if (block.generateCode) {
        return block.generateCode(this);
    } else if (AbbozzaCode[block.type]) {
        // Get the template
        var code = AbbozzaCode[block.type][0];
        var values = AbbozzaCode[block.type][1];
        if (values) {
            // Iterate through values
            for (var i = 0; i < values.length ; i ++ ) {
                // Check type of value
                var replacement = "";
                if ( typeof values[i] == "function") {
                    replacement = values[i].call(block,this);
                } else if (typeof values[i] == "string") {
                    var name = values[i].substring(2);
                    if ( values[i].match(/^F_.*/) ) {
                       replacement = this.fieldToCode(block,name);
                    } else if ( values[i].match(/^V_.*/) ) {
                       replacement = this.valueToCode(block,name);                       
                    } else if ( values[i].match(/^S_.*/) ) {
                       replacement = this.statementToCode(block,name,"   ");
                    }
                } else {
                    replacement = "";
                }
                // console.log(replacement);
                code = code.replace(/#/,replacement);
                // console.log(code);
            }
        }   
        return(code);
    } else {
        return "";
    }
}

AbbozzaGenerator.prototype.valueToCodeUnchecked = function(block,name,defaultVal) {
	// if ( this.ERROR ) return null;

	// console.log(name + " valueToCode");
	// console.log(name + " " + block.type);
	// console.log(name + " " + block.symbol);
	// console.log(block);
	if ( block.getInput(name) == null ) {
		return defaultVal;
	}
	var target = block.getInputTargetBlock(name);
	
	// console.log(name + " target");
	// console.log(target);
	
	if ( target == null ) {
		return defaultVal;
	}
	
	var code = this._toCode(target);

	// console.log(name + " end");
	
	return code;
}

AbbozzaGenerator.prototype.valueToCode = function(block,name,opt_enforcedType) {
    
	if ( block.getInput(name) == null ) {
		ErrorMgr.addError(block, _("err.NOINPUT"));
		return null;
	}
	var target = block.getInputTargetBlock(name);
		
	if ( target == null ) {
		ErrorMgr.addError(block,_("err.EMPTYINPUT"));
		return null;
	}
	
	var code = this._toCode(target);
	if ( opt_enforcedType ) {
		this.enforceType(code,opt_enforcedType);
	}
	
	return code;
}


AbbozzaGenerator.prototype.fieldToCode = function(block,name) {
    var content = block.getFieldValue(name);
    if (content == null )
        ErrorMgr.addError(block,__("err.NOVALUE"));
    if ( (content == "<default>") || ( content == "???") || (content == "<name>") ) 
        ErrorMgr.addError(block,_("err.DEFAULT_VALUE"));     
    return content;
}

AbbozzaGenerator.prototype.getTypeOfValue = function(block,name) {
	if ( block.getInput(name) == null ) {
		ErrorMgr.addError(block,_("err.NOVALUE"));
		return null;
	}
	var target = block.getInputTargetBlock(name);
	
	if ( target == null ) {
		ErrorMgr.addError(block,_("err.EMPTYVALUE"));
		return null;
	}
	
	var check = target.outputConnection.check_;
	if (!goog.isArray(check)) {
      check = [check];
	}
	for ( var i = 0; i < check.length; i++) {
		if ( (check[i] == "NUMBER") || (check[i] == "TEXT") || (check[i] == "DECIMAL") || (check[i] == "BOOLEAN")) {
			return check[i];
		}
	}
	return check[0];
}


AbbozzaGenerator.prototype.enforceType = function(code,enfType) {
	switch(enfType) {
		case "NUMBER":
			code = "int(" + code +")";
			break;
		case "TEXT":
			code = "String(int(" + code +"))";
			break;
		case "DECIMAL":
			code = "float(" + code +")";
			break;
		case "BBOLEAN":
			code = "boolean(int(" + code +") != 0 )";
			break;
	}	
}

/**
 * Naked values are top-level blocks with outputs that aren't plugged into
 * anything.  A trailing semicolon is needed to make this legal.
 * @param {string} line Line of generated code.
 * @return {string} Legal line of code.
 */
AbbozzaGenerator.prototype.scrubNakedValue = function(line) {
  return line + ';\n';
};

/**
 * Encode a string as a properly escaped JavaScript string, complete with
 * quotes.
 * @param {string} string Text to encode.
 * @return {string} JavaScript string.
 * @private
 */
AbbozzaGenerator.prototype.quote_ = function(string) {
  // TODO: This is a quick hack.  Replace with goog.string.quote
  string = string.replace(/\\/g, '\\\\')
                 .replace(/\n/g, '\\\n')
                 .replace(/'/g, '\\\'');
  return '\'' + string + '\'';
};

/**
 * Common tasks for generating JavaScript from blocks.
 * Handles comments for the specified block and any connected value blocks.
 * Calls any statements following this block.
 * @param {!Block} block The current block.
 * @param {string} code The JavaScript code created for this block.
 * @return {string} JavaScript code with comments and subsequent blocks added.
 * @private
 */
AbbozzaGenerator.prototype.scrub_ = function(block, code) {
  var commentCode = '';
  // Only collect comments for blocks that aren't inline.
  if (!block.outputConnection || !block.outputConnection.targetConnection) {
    // Collect comment for this block.
    var comment = block.getCommentText();
    if (comment) {
      commentCode += this.prefixLines(comment, '// ') + '\n';
    }
    // Collect comments for all value arguments.
    // Don't collect comments for nested statements.
    for (var x = 0; x < block.inputList.length; x++) {
      if (block.inputList[x].type == Blockly.INPUT_VALUE) {
        var childBlock = block.inputList[x].connection.targetBlock();
        if (childBlock) {
          var comment = this.allNestedComments(childBlock);
          if (comment) {
            commentCode += this.prefixLines(comment, '// ');
          }
        }
      }
    }
  }
  var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
  var nextCode = this.blockToCode(nextBlock);
  return commentCode + code + nextCode;
};

/**
 * Replaces marks by Field and input values.
 * 
 * fields: ##name##
 * inputs #name#
 */
/*
AbbozzaGenerator.prototype.replace = function(block, pattern) {

	// Search fields
	var pos = 0;
	var value = "";
	var name = "";
	while ( (pos = pattern.indexOf("##")) >= 0) {
		name = pattern.substring(pos+2);
		name = name.substring(0,name.indexOf("##"));
		value = block.getFieldValue(name);
		pattern.replace("##"+name+"##",value);
	}
	
	return pattern;
}
*/

/*
AbbozzaGenerator.prototype.checkValue = function(block,value,min,max,msg) {
		
	console.log("AbbozzaGenerator.checkValue");
	if ( (value < min) || (value > max) ) {
		if (this.ERROR_BLOCK == null) {
			console.log(block);
			this.setError(block,_(msg));
		}
	}

}
*/

AbbozzaGenerator.prototype.combine = function(text,args) {
	var pattern;
	for ( var i = 0 ; i < args.length ; i++ ) {
		pattern = "/#" + i + "/g";
		text.replace(pattern,args[i]);
		console.log(pattern);
	}
	return text;
}

AbbozzaGenerator.prototype.addPreSetup = function(line) {
	this.preSetup = this.preSetup +"\n" + line;
}

AbbozzaGenerator.prototype.addSetupCode = function(line) {
	this.setupHookCode = this.setupHookCode +"\n" + line;
}

AbbozzaGenerator.prototype.addLibrary = function(lib) {
        for (var i = 0; i < this.libraries.length; i++ ) {
            if (this.libraries[i] == lib) return;
        }
	this.libraries.push(lib);
}
